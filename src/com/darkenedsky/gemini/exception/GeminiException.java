package com.darkenedsky.gemini.exception;

import java.sql.SQLException;
import java.util.HashMap;

import com.darkenedsky.gemini.MessageSerializable;
import com.darkenedsky.gemini.Languages;
import com.darkenedsky.gemini.Message;
import com.darkenedsky.gemini.Player;

/** Core exception class for exceptions generated by Gemini.
 *  Primarily exists to add the GeminiSerializable interface, so that exceptions can easily be passed
 *  as messages back to the client when needed.
 *  
 * @author Matt Holden
 *
 */
public class GeminiException extends RuntimeException implements MessageSerializable, ExceptionCodes {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7757338362151603313L;
	
	/** The error number of the exception. Should match a constant in ExceptionCodes or one of its children. */
	protected int errorCode;
	
	/** The localized error message: the keys are language codes and values are the messages. */
	protected HashMap<String, String> errorMessage = new HashMap<String, String>();
	
	/** Message object to store any exception-soecific details we want to pass back. */
	protected Message details = new Message();
	
	/** Construct an exception
	 * 
	 * @param error	the error code of the exception type
	 * @param enError the error message in English.
	 */
	public GeminiException(int error, String enError) { 
		errorCode = error;
		errorMessage.put(Languages.ENGLISH, enError);
	}

	/** Serialize the object.
	 *  @param player the player who will be receiving the message. Make sure child classes respond favorably 
	 *  when this value is null; as it sometimes will be for exceptions.
	 *  @return the created message
	 */
	@Override
	public Message serialize(Player player) {
		Message m = new Message();
		
		// Send you the error message in the language your session has selected
		// hooray for one line of code for localization support!
		String lang = (player == null) ? Languages.ENGLISH : player.getLanguage();
		m.put("errormessage", errorMessage.get(lang));
		m.put("errorcode", errorCode);
		m.put("class", getClass().getName());
		m.put("message", getMessage());
		
		StringBuffer traceBuffer = new StringBuffer("\n");
		StackTraceElement[] stack = getStackTrace();
		for (int i = 0; i < stack.length; i++)
			traceBuffer.append(stack[i].toString() + "\n");
		m.put("stacktrace", traceBuffer.toString());
		
		Throwable cause = getCause();
		if (cause != null)
			m.put("cause", new JavaException(getCause()), player);
		
		m.put("details", details, player);
		
		return m;
	}
	
	/** Read the message of an SQL Exception to see if it's been set up to translate to a Gemini exception.
	 * This occurs when we've used the "raise exception" syntax in a PostgreSQL function to return one of
	 * our own errors. Will give you back a new instance of the correctly "translated" error if one is found;
	 * otherwise simply returns the SQL Exception.
	 * 
	 * @param sql the SQL exception to translate
	 * @return the translated exception if applicable, otherwise, the original SQLException
	 */
	@SuppressWarnings("unchecked")
	public static Exception translateSQLException(SQLException sql) { 
		
		try { 
			String msg = sql.getMessage();
			Class<? extends GeminiException> clazz = (Class<? extends GeminiException>) Class.forName(msg);
			return clazz.newInstance();
		}
		catch (Exception x) { 
			return sql;
		}
		
	}
	
}
